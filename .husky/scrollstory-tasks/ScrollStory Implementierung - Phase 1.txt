ScrollStory Implementierung - Phase 1: Foundation & Core Architecture
Ziel: Schaffung der grundlegenden Projektinfrastruktur, Einrichtung des SVG/2.5D-Layer-Stacks und Aufbau der Kernkomponenten. Diese Phase legt das stabile Fundament f√ºr die komplexen visuellen und interaktiven Features der Folgephasen.

Dauer: 2 Wochen

Fokus: Stabile SVG-Layer-Architektur, grundlegende Komponentenstruktur, Performance-Baseline und Einrichtung des Scroll-Trackings.

üì¶ Dependencies & Setup
[x] 1.1: Libraries installieren

F√ºhre den folgenden Befehl aus, um alle notwendigen Animations- und SVG-Hilfsbibliotheken zu installieren.

npm install framer-motion

[x] 1.2: Testing-Libraries verifizieren

Stelle sicher, dass @testing-library/react und vitest korrekt konfiguriert sind, um die neuen Komponenten zu testen.

üìÅ File & Component Structure
[x] 2.1: Verzeichnisstruktur anlegen

Erstelle die folgende Verzeichnisstruktur innerhalb von src/, um die neuen Komponenten und Hooks zu organisieren.

src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ scroll-story/
‚îÇ       ‚îú‚îÄ‚îÄ layers/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ BlueprintLayer1.tsx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ BlueprintLayer2.tsx
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ BlueprintLayer3.tsx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ BlueprintLayer4.tsx
‚îÇ       ‚îú‚îÄ‚îÄ ui/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ Panel.tsx
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ ExpertInsight.tsx
‚îÇ       ‚îî‚îÄ‚îÄ ScrollStoryContainer.tsx
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ useScrollProgress.ts
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ scrollstory.ts

[x] 2.2: TypeScript-Typen definieren

Erstelle in src/types/scrollstory.ts die grundlegenden Typdefinitionen f√ºr die narrativen Phasen, Panels und SVG-Layer.

üèóÔ∏è Core Component Implementation
[x] 3.1: ScrollStoryContainer.tsx erstellen

Ziel: Die Haupt-Wrapper-Komponente, die den Scroll-Bereich definiert und den State f√ºr die gesamte Experience verwaltet.

Anforderungen:
[x] Erstelle eine Komponente, die ein div mit einer fixen H√∂he rendert (z.B. 400vh), um den Scroll-Bereich zu erzeugen.
[x] Nutze einen useRef f√ºr das scrollbare Container-Element.
[x] Implementiere einen State (z.B. mit useState), um den Scroll-Fortschritt (progress) zu speichern.
[x] Binde hier die SVG-Layer-Komponenten und die UI-Elemente ein.

[x] 3.2: useScrollProgress.ts Hook erstellen

Ziel: Ein wiederverwendbarer Hook, der den Scroll-Fortschritt innerhalb eines Elements von 0 bis 1 misst.

Anforderungen:
[x] Der Hook soll eine ref auf ein DOM-Element als Argument akzeptieren.
[x] F√ºge einen scroll-Event-Listener zum window hinzu.
[x] Berechne den prozentualen Scroll-Wert basierend auf der Position des Elements im Viewport.
[x] Gib den Fortschritt (eine Zahl zwischen 0 und 1) zur√ºck.

[ ] Testing: Schreibe Unit-Tests f√ºr den Hook, die das Scroll-Verhalten simulieren und den korrekten Fortschrittswert √ºberpr√ºfen.

[x] 3.3: BlueprintLayer-Komponenten erstellen

Ziel: Die zentralen SVG-Layer-Komponenten f√ºr jede Story-Phase.

Anforderungen:
[x] Jede Phase erh√§lt eine eigene SVG-Komponente (BlueprintLayer1-4).
[x] Die Layer werden im Stack gerendert und k√∂nnen einzeln animiert werden.
[x] Die Layer sind so gestaltet, dass sie fragmentiert, hervorgehoben und mit Panels/Insights kombiniert werden k√∂nnen.

[x] 3.4: Panel.tsx (Overlay) erstellen

Ziel: Eine Panel-Komponente, die die Schl√ºsselw√∂rter und Inhalte jeder Phase als Overlay anzeigt.

Anforderungen:
[x] Panel ist ein zentrales UI-Overlay, das zur aktuellen Phase passt.
[x] Styling mit Tailwind CSS und Framer Motion f√ºr Ein-/Ausblend-Animationen.

[x] Checkpoint: Auf der Seite sollte nun eine scrollbare Fl√§che, ein SVG-Layer-Stack und ein Panel-Overlay sichtbar sein.

üß™ Testing & Validation
[ ] 4.1: useScrollProgress Hook testen

Ziel: Sicherstellen, dass der Scroll-Fortschritt pr√§zise berechnet wird.

Anforderungen:
[ ] Schreibe einen Vitest-Test, der den Hook rendert und ein simuliertes Scroll-Event ausl√∂st.
[ ] √úberpr√ºfe, ob der zur√ºckgegebene Wert korrekt ist (z.B. 0.5 bei halbem Scrollen).

[ ] 4.2: ScrollStoryContainer Integrationstest

Ziel: Sicherstellen, dass der Container die SVG-Layer korrekt einbettet und der Scroll-Hook angebunden ist.

Anforderungen:
[ ] Erstelle einen Test mit @testing-library/react.
[ ] Rendere den ScrollStoryContainer.
[ ] √úberpr√ºfe, ob das SVG-Element im DOM vorhanden ist.
[ ] Simuliere ein Scroll-Event und stelle sicher, dass der State (oder ein angebundenes Element) entsprechend aktualisiert wird.

üöÄ Performance & Quality Assurance
[x] 5.1: Performance-Baseline erstellen

Ziel: Einen initialen Performance-Wert als Referenz f√ºr zuk√ºnftige Optimierungen festlegen.

Anforderungen:
[x] Integriere die web-vitals-Bibliothek in src/app/layout.tsx oder einer √§quivalenten globalen Datei.
[x] Logge die Core Web Vitals (LCP, INP, CLS) in der Konsole.
[x] F√ºhre einen initialen Lighthouse-Audit durch und speichere den Report.

Benchmark-Ziel: Lighthouse Score > 95 f√ºr Performance (ohne SVG-Last).

[ ] 5.2: Code-Qualit√§t sicherstellen

Ziel: Einhaltung der Projektstandards.

Anforderungen:
[ ] Aktiviere den TypeScript strict mode f√ºr alle neuen Dateien.
[ ] Konfiguriere Biome/ESLint, um die neuen Verzeichnisse zu linten und zu formatieren.
[ ] Richte einen Git-Hook (Husky) ein, der den Linter vor jedem Commit ausf√ºhrt.

Phasen-Abschluss-Check:

Die grundlegende Architektur steht.
Ein SVG-Layer-Stack und ein Panel-Overlay werden gerendert.
Der Scroll-Fortschritt wird zuverl√§ssig getrackt.
Alle neuen Komponenten und Hooks haben grundlegende Tests.
Eine Performance-Baseline ist dokumentiert.