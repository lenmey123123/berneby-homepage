# ScrollStory Implementierung - Phase 3: Narrative & Scroll Integration

**Ziel:** Die Verbindung zwischen dem Scroll-Fortschritt des Nutzers und der 3D-Szene herstellen. Dies beinhaltet die Implementierung der "DeKonstruktions"-Animationen, die Steuerung der Kamera und die dynamische Anzeige der narrativen Inhalte basierend auf der Scroll-Position.

**Dauer:** 3 Wochen

**Fokus:** GSAP-Timeline-Management, Synchronisation von Scroll-Fortschritt mit Animationen, Kamera-Choreografie und Zustandsmanagement f√ºr die narrativen Phasen.

---

## üîó Scroll-Animation-Synchronisation

- [ ] **1.1: GSAP als Animations-Engine integrieren**
  - **Ziel:** GSAP f√ºr pr√§zise, steuerbare und performante Timeline-Animationen nutzen.
  - **Anforderungen:**
    - [ ] Stelle sicher, dass `gsap` aus Phase 1 installiert ist.
    - [ ] Erstelle eine zentrale Animations-Timeline in `ScrollStoryContainer.tsx` mit `gsap.timeline()`. Setze `paused: true`, da wir die Timeline manuell steuern.

- [ ] **1.2: `useScrollProgress` mit GSAP-Timeline verbinden**
  - **Ziel:** Den Scroll-Fortschritt nutzen, um die GSAP-Timeline vor- und zur√ºckzuspulen.
  - **Anforderungen:**
    - [ ] In `ScrollStoryContainer.tsx`, nutze einen `useEffect`, der auf √Ñnderungen des `progress`-Wertes vom `useScrollProgress`-Hook reagiert.
    - [ ] Innerhalb des Effekts, rufe `timeline.seek(progress * timeline.duration())` auf. Dies synchronisiert die Animation direkt mit der Scroll-Position.

- [ ] **1.3: State Management f√ºr die narrative Phase einrichten**
  - **Ziel:** Jederzeit wissen, in welcher der vier DeKonstruktions-Phasen sich der Nutzer befindet.
  - **Anforderungen:**
    - [ ] Nutze ein State-Management-Tool (z.B. Zustand, empfohlen f√ºr R3F) oder einen React Context, um den globalen Zustand (`progress`, `currentPhase`) zu verwalten.
    - [ ] Erstelle in `ScrollStoryContainer.tsx` eine Logik, die den `progress` in eine `currentPhase` √ºbersetzt (z.B. 0-0.25 -> 'LIVE_PRODUCT', 0.25-0.5 -> 'UI_UX', etc.).
    - [ ] Speichere die `currentPhase` im globalen Store.

---

## üé• Kamera-Choreografie

- [ ] **2.1: `CameraControls` von `@react-three/drei` einrichten**
  - **Ziel:** Eine flexible und animierbare Kamerasteuerung.
  - **Anforderungen:**
    - [ ] Importiere `<CameraControls />` in `Scene.tsx`.
    - [ ] Deaktiviere die User-Interaktion, da die Kamera durch das Scrollen gesteuert wird: `mouseButtons.left={0}` `touches.one={0}`.
    - [ ] Hole dir eine `ref` auf die `CameraControls`, um sie von au√üen steuern zu k√∂nnen.

- [ ] **2.2: Kamerafahrten zur GSAP-Timeline hinzuf√ºgen**
  - **Ziel:** Die Kamera soll in jeder Phase eine andere Perspektive auf das Artefakt einnehmen.
  - **Anforderungen:**
    - [ ] Definiere f√ºr jede der vier Phasen eine Ziel-Kameraposition und ein Ziel-Target (Blickpunkt).
    - [ ] Erstelle in `ScrollStoryContainer.tsx` eine Funktion, die die `CameraControls`-Ref entgegennimmt.
    - [ ] F√ºge der GSAP-Timeline Animationen hinzu, die `controls.setLookAt(...)` mit den Zieldaten f√ºr jede Phase aufrufen. Nutze die `duration`- und `delay`-Parameter von GSAP, um die √úberg√§nge an die Phasenl√§ngen (jeweils 25% der Timeline) anzupassen.
    - **Beispiel:**
      ```javascript
      // In der Timeline-Definition
      timeline.to(controls, {
        // Parameter f√ºr setLookAt
        // ...
        duration: 1, // Entspricht 25% der Gesamtdauer von 4
      }, 0); // Startet bei 0s
      timeline.to(controls, {
        // N√§chste Kameraposition
        // ...
        duration: 1,
      }, 1); // Startet bei 1s
      ```

---

## üí• DeKonstruktions-Animationen

- [ ] **3.1: Artefakt-H√ºlle fragmentieren**
  - **Ziel:** Die √§u√üere H√ºlle muss in animierbare Einzelteile zerlegt werden.
  - **Anforderungen:**
    - [ ] Anstatt einer einzelnen `DodecahedronGeometry`, erstelle f√ºr jede Fl√§che des Dodekaeders ein eigenes `THREE.Mesh`.
    - [ ] **Technik:** Iteriere durch die Vertices der `DodecahedronGeometry` und erstelle f√ºr jede polygonale Fl√§che (F√ºnfeck) ein eigenes `ShapeGeometry`-Mesh.
    - [ ] Gruppiere alle Fragmente in einer `<group ref={shellRef}>`.

- [ ] **3.2: DeKonstruktions-Animation zur GSAP-Timeline hinzuf√ºgen**
  - **Ziel:** Die Schichten des Artefakts sollen sich entsprechend der narrativen Phasen aufl√∂sen.
  - **Anforderungen:**
    - [ ] **Phase 1 -> 2 (UI/UX):** Animiere die Fragmente der √§u√üeren H√ºlle. Bewege sie von ihrer urspr√ºnglichen Position nach au√üen, als w√ºrden sie explodieren. F√ºge diese Animationen zur GSAP-Timeline im Bereich von `progress` 0.25 bis 0.5 hinzu.
    - [ ] **Phase 2 -> 3 (Architektur):** Animiere die "Datenstrom"-Tori. Lasse sie verblassen (`material.opacity`) und sich aufl√∂sen (z.B. Skalierung auf 0). F√ºge dies zur Timeline im Bereich 0.5 bis 0.75 hinzu.
    - [ ] **Phase 3 -> 4 (Konzept):** Der Kern bleibt sichtbar. Es sind keine weiteren DeKonstruktions-Animationen f√ºr das Artefakt selbst n√∂tig.

- [ ] **3.3: `HolographicPanel`-Animationen**
  - **Ziel:** Die passenden holografischen Tafeln f√ºr jede Phase ein- und ausblenden.
  - **Anforderungen:**
    - [ ] Erstelle in `Scene.tsx` vier Instanzen von `HolographicPanel`, eine f√ºr jede narrative Phase.
    - [ ] Gib jeder Tafel einen eindeutigen Namen oder eine ID.
    - [ ] Steuere die `visible`-Eigenschaft und die `opacity` des Materials jeder Tafel √ºber die GSAP-Timeline.
    - **Logik:**
      - Phase 1 (0-0.25): Tafel 1 ist sichtbar.
      - √úbergang (bei 0.25): Blende Tafel 1 aus, blende Tafel 2 ein.
      - Phase 2 (0.25-0.5): Tafel 2 ist sichtbar.
      - usw.

---

## üß™ Testing & Validation

- [ ] **4.1: Visuelles Debugging der Animationen**
  - **Ziel:** Die Synchronisation und das Timing der Animationen √ºberpr√ºfen.
  - **Anforderungen:**
    - [ ] Nutze ein Debug-UI-Panel wie `leva` oder `dat.gui`.
    - [ ] F√ºge einen Slider hinzu, der den `progress`-Wert (0-1) manuell steuert. Dies erlaubt es, die gesamte Animation ohne Scrollen zu √ºberpr√ºfen.
    - [ ] **Checkpoint:** Beim Bewegen des Sliders sollte die gesamte DeKonstruktions-Sequenz inklusive Kamerafahrten und Panel-Wechsel fl√ºssig und synchron ablaufen.

- [ ] **4.2: State-Management-Tests**
  - **Ziel:** Sicherstellen, dass der `currentPhase`-State korrekt aktualisiert wird.
  - **Anforderungen:**
    - [ ] Schreibe einen Unit-Test f√ºr den Zustandsspeicher (z.B. den Zustand-Store).
    - [ ] Simuliere eine √Ñnderung des `progress`-Wertes und √ºberpr√ºfe, ob die `currentPhase` korrekt auf 'LIVE_PRODUCT', 'UI_UX' etc. wechselt.

- [ ] **4.3: Browser-Kompatibilit√§t pr√ºfen**
  - **Ziel:** Die Darstellung auf verschiedenen Browsern (Chrome, Firefox, Safari) sicherstellen.
  - **Anforderungen:**
    - [ ] Teste die Seite manuell in den Zielbrowsern.
    - [ ] Achte besonders auf die Performance von Animationen und die Darstellung der CSS-gestylten `Html`-Komponente.
